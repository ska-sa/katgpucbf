"""
Module to launch the XB-Engine.

This module parses all command line arguments required to configure the XB-Engine and creates an XBEngineProcessingLoop
object. The XBEngineProcessingLoop object then manages everything required to run the XB-Engine.

TODO:
The command line parameters could be made more intuitive, for example instead of having mcast addresses and port
numbers as seperate arguments, accept something formatted as "<ip address>:<port number>" and parse the argument to
seperate out the parameters. Additionally checks need to be put in place to ensure the command line parameters are
correct - is the port number valid, is the IP address a multicast address, is the array size >0, etc. As a first step
for this, I would look at the [main.py](https://github.com/ska-sa/katfgpu/blob/master/katfgpu/main.py) file in katfgpu
as this uses some useful parsing functions that could be of use here.
"""

import argparse
import asyncio
import katxgpu.xbengine_proc_loop


def parse_args() -> argparse.Namespace:
    """Parse all command line parameters for the XB-Engine and ensure that they are valid."""
    # 1. Create command line parsing argument and set help menu description
    parser = argparse.ArgumentParser(description="Launch an XB-Engine for a single multicast stream.")

    # 2. Configure flagged arguments
    parser.add_argument(
        "--adc-sample-rate",
        type=int,
        default=1712000000,
        help="Digitiser sample rate (Hz). If this value is set lower than the actual rate, the pipeline will stall."
        "[%(default)s]",
    )
    parser.add_argument("--array-size", type=int, default=64, help="Number of antennas in the array. [%(default)s]")
    parser.add_argument(
        "--channels-total",
        type=int,
        default=32768,
        help="Total number of channels out of the F-Engine FFT. [%(default)s]",
    )
    parser.add_argument(
        "--channels-in-stream",
        type=int,
        default=128,
        help="Number of channels in the multicast stream that this engine receives data from. [%(default)s]",
    )
    parser.add_argument(
        "--channel-offset-value",
        type=int,
        default=0,
        help="First channel in the range of channels that this engine must process. [%(default)s]",
    )
    parser.add_argument(
        "--samples-per-channel",
        type=int,
        default=256,
        help="Number of packed samples in every received channel. [%(default)s]",
    )
    parser.add_argument("--pols", type=int, default=2, help="Number of polarisations per antenna. [%(default)s]")
    parser.add_argument(
        "--sample-bits",
        type=int,
        default=8,
        help="Number of bits for each real and imaginary value in a sample. [%(default)s]",
    )
    parser.add_argument(
        "--batches-per-chunk",
        type=int,
        default=5,
        help="A batch is a collection of heaps from different antennas with the same timestamp. This parameter "
        "specifies the number of consecutive batches to store in the same chunk. The higher this value is, the "
        "more GPU and system RAM is allocated, the lower this value is, the more work the python processing thread "
        "is required to do. [%(default)s]",
    )
    parser.add_argument(
        "--heap-accumulation-threshold",
        type=int,
        default=52,
        help="Number of batches of heaps to accumulate in an accumulation epoch. [%(default)s]",
    )
    parser.add_argument(
        "--receiver-thread-affinity", type=int, required=True, help="Core to which the reciever thread must be bound."
    )
    parser.add_argument(
        "--receiver-comp-vector-affinity",
        type=int,
        required=True,
        help="Core to which the interrupts generated by the receiver must be sent to.",
    )
    parser.add_argument(
        "--src-interface-address",
        type=str,
        required=True,
        help="IP address of the interface receiving data from the F-Engines",
    )
    parser.add_argument(
        "--sender-thread-affinity", type=int, required=True, help="Core to which the sender thread must be bound."
    )
    parser.add_argument(
        "--dest-interface-address",
        type=str,
        required=True,
        help="IP address of the interface that this engine will transmit data on.",
    )

    # 3. Set positional arguments
    parser.add_argument("src_multicast_address", type=str, help="Multicast address data is received from.")
    parser.add_argument("src_port", type=int, help="Port data is received from.")
    parser.add_argument("dest_multicast_address", type=str, help="Multicast address data is sent on.")
    parser.add_argument("dest_port", type=int, help="Port data is sent on.")

    # 4. Read in command line arguments into ArgumentParser object
    args = parser.parse_args()

    # 5. Verify that the command line arguments are valid.
    if args.pols != 2:
        parser.error("Only 2 polarisations per antenna currently supported.")

    if args.sample_bits != 8:
        parser.error("Only 8 bit values are currently supported.")

    # 6. Return
    return args


async def async_main() -> None:
    """
    Create and launch the XB-Engine.

    This function creates the XBEngineProcessingLoop object. It attaches the ibverbs sender and receiver transports to
    the XBEngineProcessingLoop object and then tells the object to launch all its internal asyncio functions.
    """
    args = parse_args()

    print("Print Initialising XB-Engine")
    xbengine_proc_loop = katxgpu.xbengine_proc_loop.XBEngineProcessingLoop(
        adc_sample_rate_Hz=args.adc_sample_rate,
        n_ants=args.array_size,
        n_channels_total=args.channels_total,
        n_channels_per_stream=args.channels_in_stream,
        n_samples_per_channel=args.samples_per_channel,
        n_pols=args.pols,
        sample_bits=args.sample_bits,
        heap_accumulation_threshold=args.heap_accumulation_threshold,
        channel_offset_value=args.channel_offset_value,
        rx_thread_affinity=args.receiver_thread_affinity,
        batches_per_chunk=args.batches_per_chunk,
    )

    xbengine_proc_loop.add_udp_ibv_receiver_transport(
        src_ip=args.src_multicast_address,
        src_port=args.src_port,
        interface_ip=args.src_interface_address,
        comp_vector_affinity=args.receiver_comp_vector_affinity,
    )

    xbengine_proc_loop.add_udp_ibv_sender_transport(
        dest_ip=args.dest_multicast_address,
        dest_port=args.dest_port,
        interface_ip=args.dest_interface_address,
        thread_affinity=args.sender_thread_affinity,
    )

    print("Starting main processing loop")

    await xbengine_proc_loop.run()
    await xbengine_proc_loop.run_descriptors_loop(5)


def main() -> None:
    """
    Launch the XB-Engine pipeline.

    This method only sets up the asyncio loop and calls the async_main() method which is where the real work is done.
    """
    loop = asyncio.get_event_loop()
    try:
        loop.run_until_complete(async_main())
    finally:
        loop.run_until_complete(loop.shutdown_asyncgens())
        loop.close()


if __name__ == "__main__":
    main()
