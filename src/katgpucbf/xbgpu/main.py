"""
Module to launch the XB-Engine.

This module parses all command line arguments required to configure the XB-Engine and creates an XBEngine
object. The XBEngine object then manages everything required to run the XB-Engine.

TODO:
The command line parameters could be made more intuitive, for example instead of having mcast addresses and port
numbers as seperate arguments, accept something formatted as "<ip address>:<port number>" and parse the argument to
seperate out the parameters. Additionally checks need to be put in place to ensure the command line parameters are
correct - is the port number valid, is the IP address a multicast address, is the array size >0, etc. As a first step
for this, I would look at the [main.py](https://github.com/ska-sa/katfgpu/blob/master/katfgpu/main.py) file in katfgpu
as this uses some useful parsing functions that could be of use here.
"""

import argparse
import asyncio
import logging

import katsdpservices

import katgpucbf.xbgpu.xbengine
from katgpucbf.xbgpu.monitor import FileMonitor, Monitor, NullMonitor

DEFAULT_KATCP_PORT = 7147
DEFAULT_KATCP_HOST = ""  # Default to all interfaces, but user can override with a specific one.

logger = logging.getLogger(__name__)


def parse_args() -> argparse.Namespace:
    """Parse all command line parameters for the XB-Engine and ensure that they are valid."""
    parser = argparse.ArgumentParser(description="Launch an XB-Engine for a single multicast stream.")
    parser.add_argument(
        "--katcp-host",
        type=str,
        default=DEFAULT_KATCP_HOST,
        help="Hostname or IP address on which to listen for KATCP C&M connections [all interfaces]",
    )
    parser.add_argument(
        "--katcp-port",
        type=int,
        default=DEFAULT_KATCP_PORT,
        help="TCP port on which to listen for KATCP C&M connections [%(default)s]",
    )
    parser.add_argument(
        "--adc-sample-rate",
        type=float,
        default=1712000000.0,
        help="Digitiser sample rate (Hz). If this value is set lower than the actual rate, the pipeline will stall."
        "[%(default)s]",
    )
    parser.add_argument("--array-size", type=int, default=64, help="Number of antennas in the array. [%(default)s]")
    parser.add_argument(
        "--channels-total",
        type=int,
        default=32768,
        help="Total number of channels out of the F-Engine PFB. [%(default)s]",
    )
    parser.add_argument(
        "--channels-in-stream",
        type=int,
        default=128,
        help="Number of channels in the multicast stream that this engine receives data from. [%(default)s]",
    )
    parser.add_argument(
        "--channel-offset-value",
        type=int,
        default=0,
        help="Index of the first channel in the subset of channels processed by this XB-Engine. Used to set the value "
        "in the XB-Engine output heaps for spectrum reassembly by the downstream receiver. [%(default)s]",
    )
    parser.add_argument(
        "--samples-per-channel",
        type=int,
        default=256,
        help="Number of packed samples in every received channel. [%(default)s]",
    )
    parser.add_argument("--pols", type=int, default=2, help="Number of polarisations per antenna. [%(default)s]")
    parser.add_argument(
        "--sample-bits",
        type=int,
        default=8,
        help="Number of bits for each real and imaginary value in a sample. [%(default)s]",
    )
    parser.add_argument(
        "--batches-per-chunk",
        type=int,
        default=5,
        help="A batch is a collection of heaps from different F-Engines with the same timestamp. This parameter "
        "specifies the number of consecutive batches to store in the same chunk. The higher this value is, the "
        "more GPU and system RAM is allocated, the lower this value is, the more work the python processing thread "
        "is required to do. [%(default)s]",
    )
    parser.add_argument(
        "--rx-reorder-tol",
        type=int,
        default=2 ** 29,
        help="Maximum time (in ADC ticks) that packets can be delayed relative to others "
        "and still be accepted. [%(default)s]",
    )
    parser.add_argument(
        "--heap-accumulation-threshold",
        type=int,
        default=52,
        help="Number of batches of heaps to accumulate in a single dump. [%(default)s]",
    )
    parser.add_argument(
        "--receiver-thread-affinity", type=int, required=True, help="Core to which the receiver thread must be bound."
    )
    parser.add_argument(
        "--receiver-comp-vector-affinity",
        type=int,
        required=True,
        help="Core to which the interrupts generated by the receiver must be sent to.",
    )
    parser.add_argument(
        "--src-interface-address",
        type=str,
        required=True,
        help="IP address of the interface receiving data from the F-Engines",
    )
    parser.add_argument(
        "--sender-thread-affinity", type=int, required=True, help="Core to which the sender thread must be bound."
    )
    parser.add_argument(
        "--dest-interface-address",
        type=str,
        required=True,
        help="IP address of the interface that this engine will transmit data on.",
    )
    parser.add_argument("--monitor-log", type=str, help="File to write performance-monitoring data to")

    parser.add_argument("src_multicast_address", type=str, help="Multicast address data is received from.")
    parser.add_argument("src_port", type=int, help="Port data is received from.")
    parser.add_argument("dest_multicast_address", type=str, help="Multicast address data is sent on.")
    parser.add_argument("dest_port", type=int, help="Port data is sent on.")

    args = parser.parse_args()

    if args.pols != 2:
        parser.error("Only 2 polarisations per antenna currently supported.")

    if args.sample_bits != 8:
        parser.error("Only 8-bit values are currently supported.")

    return args


async def async_main(args: argparse.Namespace) -> None:
    """
    Create and launch the XB-Engine.

    This function creates the XBEngine object. It attaches the ibverbs sender and receiver transports to
    the XBEngine object and then tells the object to launch all its internal asyncio functions.

    Parameters
    ----------
    args: argparse.Namespace
        Command line parameter arguments generated by argparse.
    """
    # TODO: fgpu uses a make_engine method that returns the Engine and a Monitor
    #       - The Monitor is then used in a Context Manager in main.py.
    #       - This is the ultimate goal for the XB-Engine as well.

    monitor: Monitor
    if args.monitor_log is not None:
        monitor = FileMonitor(filename=args.monitor_log)
    else:
        monitor = NullMonitor()

    logger.info("Initialising XB-Engine")
    xbengine = katgpucbf.xbgpu.xbengine.XBEngine(
        katcp_host=args.katcp_host,
        katcp_port=args.katcp_port,
        adc_sample_rate_hz=args.adc_sample_rate,
        n_ants=args.array_size,
        n_channels_total=args.channels_total,
        n_channels_per_stream=args.channels_in_stream,
        n_samples_per_channel=args.samples_per_channel,
        n_pols=args.pols,
        sample_bits=args.sample_bits,
        heap_accumulation_threshold=args.heap_accumulation_threshold,
        channel_offset_value=args.channel_offset_value,
        rx_thread_affinity=args.receiver_thread_affinity,
        batches_per_chunk=args.batches_per_chunk,
        rx_reorder_tol=args.rx_reorder_tol,
        monitor=monitor,
    )

    # Attach this transport to receive channelisation products from the network at high rates.
    xbengine.add_udp_ibv_receiver_transport(
        src_ip=args.src_multicast_address,
        src_port=args.src_port,
        interface_ip=args.src_interface_address,
        comp_vector_affinity=args.receiver_comp_vector_affinity,
    )

    # Attach this transport to send the baseline correlation products to the network.
    xbengine.add_udp_ibv_sender_transport(
        dest_ip=args.dest_multicast_address,
        dest_port=args.dest_port,
        interface_ip=args.dest_interface_address,
        thread_affinity=args.sender_thread_affinity,
    )

    logger.info("Starting main processing loop")

    loop = asyncio.get_event_loop()
    main_task = loop.create_task(xbengine.run())
    descriptor_task = loop.create_task(xbengine.run_descriptors_loop(5))
    await main_task
    await descriptor_task


def main() -> None:
    """
    Launch the XB-Engine pipeline.

    This method only sets up the asyncio loop and calls the async_main() method which is where the real work is done.
    """
    args = parse_args()
    katsdpservices.setup_logging()
    asyncio.run(async_main(args))


if __name__ == "__main__":
    main()
