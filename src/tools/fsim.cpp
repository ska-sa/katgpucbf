/*******************************************************************************
 * Copyright (c) 2020-2021, National Research Foundation (SARAO)
 *
 * Licensed under the BSD 3-Clause License (the "License"); you may not use
 * this file except in compliance with the License. You may obtain a copy
 * of the License at
 *
 *   https://opensource.org/licenses/BSD-3-Clause
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/

/* This program creates a simulator for channelised data from the MeerKAT F-Engines destined for a single X-Engine.
 * When there are N antennas, the X-Engine receives channels from N F-Engines. This simulator simulates this behaviour
 * by interleaving packets with differently-populated fields designed to mimic the different antennas. One caveat to
 * this simulator is that the data is perfectly interleaved and ordered. It does not simulate the messier environment
 * that occurs when running multiple real F-Engines all transmitting along different paths.
 *
 * This simulator was modified from the dsim.cpp document found within katfgpu:
 * https://github.com/ska-sa/katfgpu/blob/master/scratch/dsim.cpp
 *
 * This simulator uses the spead2 library to transmit the F-Engine data. spead2 uses ibverbs to accelerate packet
 * transmission. Lossless transmit rates up to 55 Gbps have been tested, but it is expected that higher rates can be
 * achieved. By default the cap_net_raw capability is required to use ibverbs.
 *
 * The minimum command to run the fsim is:
 * spead2_net_raw ./fsim --interface <interface_address> <multicast_address>[+y]:<port>
 * Where:
 * <interface_address> is the ip address of the network interface to transmit the data out on.
 * <multicast_address> is the multicast address all packets are destined for. The optional [+y] argument will create
 * [+7] multicast streams with the same parameters each on a different multicast addresses consecutivly after the base
 * address.
 * <port> is the UDP port to transmit data to.
 *
 * By default the fsim transmits data at 27.4 Gbps + packet overhead. This depends on the sample rate of the antenna
 * ADCs, the number of antennas, and the fraction of the band transmitted. The data rate is equal to
 * adc_rate * number_of_pols * sample_size_bits * antennas * (channels_per_substream / fft_channels)
 * = 1712000000 * 2 * 8 * 64 * (512/32768) = 27.4 Gbps.
 * In this example if the [+y] argument is specified, the total rate out of the fsim is equal to
 * 6.8 * (y + 1) Gbps. To change the rate pass command-line arguments.
 *
 * This file has an "fengines" class that manages the SPEAD streams and packet transmission. The fengines object
 * contains a 2 dimensional vector of heaps. The outer dimension represents the different F-Engines and the inner
 * dimension contains the heaps to send per F-Engine. The array of heaps is generated once and then transmitted
 * repeatedly on the network. A seperate fengines object is generated for each multicast stream.
 *
 * The format of the data generated by the fsim is discussed in the heap_data class below.
 *
 * TODO: Describe the generated data and how it is expected to look after correlation. This should become its own
 * document.
 */

#include <spead2/send_udp_ibv.h>

#include <boost/program_options.hpp>
#include <cmath>
#include <cstdint>
#include <cstdlib>
#include <deque>
#include <iomanip>
#include <iostream>
#include <memory>
#include <random>
#include <vector>

struct options
{
    std::string interface_name;
    std::string strAddress;
    int max_heaps = 8;
    double adc_sample_rate = 1712000000.0;
    int ttl = 4;
    int n_ants = 64;
    int n_chans_per_output_stream = 512;
    int n_chans_total = 32768;
    int n_spectra_per_heap = 256;
    size_t packet_payload_size_bytes = 8192;
    bool run_once = false;

    // The variables below are not command-line arguments, they are just calculated based on values provided by the
    // command line. This method of passing these arguments is a bit clunky, but I have not put effort into fixing it.
    size_t heap_size_bytes;
    size_t packets_per_heap;
    size_t timestamp_step; // This is the amount the timestamp must increment between successive heaps of the same
                        // F-Engine.
};

// TODO: These constexpr could be neatened up a bit.

static constexpr int SAMPLE_BITS = 8; // This is not very meaningful for the X-Engine but this argument is left here to
                                      // be consistent with the F-Engine packet simulator.
static constexpr size_t N_POLS = 2;                    // Dual polarisation antennas
static constexpr size_t COMPLEXITY = 2;                // real and imaginary components
static constexpr size_t PACKET_HEADER_SIZE_BYTES = 96; // Nine 8-byte header fields and three padding fields.

// The 64 indicates that each header spead2 item is 64-bits wide. The 48 value means that the ItemPointers will have 48
// bits representing the immediate value or pointer to payload. The other 16 bits will be used for the item ID.
static const spead2::flavour FLAVOUR(4, 64, 48);

// Function to assist with parsing command line parameters
template <typename T> static boost::program_options::typed_value<T> *make_opt(T &var)
{
    return boost::program_options::value<T>(&var)->default_value(var);
}

// Parse command line parameters - this has been kludged  together. It can probably be done in a neater way.
static options parse_options(int argc, const char **argv)
{
    options opts;
    boost::program_options::options_description desc, hidden, all("F- to X- Engine simulator");
    desc.add_options()("help", "produce help message");
    desc.add_options()("interface", boost::program_options::value(&opts.interface_name)->required(),
                       "Interface address to send data out on");
    desc.add_options()("max-heaps", make_opt(opts.max_heaps), "Maximum number of heaps per F-Engine");
    desc.add_options()("adc-sample-rate", make_opt(opts.adc_sample_rate), "Sampling rate of digitisers feeding the F-Engine");
    desc.add_options()("ttl", make_opt(opts.ttl), "Output TTL (Time to live)");
    desc.add_options()("array-size", make_opt(opts.n_ants), "Number of antennas in the array");
    desc.add_options()("channels", make_opt(opts.n_chans_total),
                       "Number of channels out of the FFT. (Normally half of FFT size)");
    desc.add_options()("channels-per-substream", make_opt(opts.n_chans_per_output_stream),
                       "Each F-Engine output substream transmits a subset of the FFT channels");
    desc.add_options()("spectra-per-heap", make_opt(opts.n_spectra_per_heap),
                       "The F-Engine cornerturn groups a number of samples into each channel per packet");
    desc.add_options()("dst-packet-payload", make_opt(opts.packet_payload_size_bytes),
                       "The number of payload bytes per packet");
    desc.add_options()("run-once", make_opt(opts.run_once), "Transmit a single collection of heaps before exiting");
    hidden.add_options()(
        "address", boost::program_options::value<std::string>(&opts.strAddress)->composing(),
        "destination address, in form x.x.x.x[+y]:port where y represents the number of additional multicast streams "
        "to launch in parallel. Each stream is assigned the next consecutive multicast address from the x.x.x.x base.");
    all.add(desc);
    all.add(hidden);
    boost::program_options::positional_options_description positional;
    positional.add("address", -1);
    try
    {
        boost::program_options::variables_map var_map;
        boost::program_options::store(
            boost::program_options::command_line_parser(argc, argv).options(all).positional(positional).run(), var_map);
        boost::program_options::notify(var_map);
        if (opts.max_heaps <= 0)
            throw boost::program_options::error("--max-heaps must be positive");

        if (var_map.count("help"))
        {
            std::cout << all << "\n";
            std::exit(1);
        }
    }
    catch (boost::program_options::error &e)
    {
        std::cerr << e.what() << '\n';
        std::exit(2);
    }

    /*
     * NOTE: For the F-Engine output case, each heap is quite large but
     * contains many smaller packets. Each packet also contains other SPEAD
     * data and is thus slightly larger than the payload size.
     */
    opts.heap_size_bytes =
        opts.n_chans_per_output_stream * opts.n_spectra_per_heap * N_POLS * COMPLEXITY * SAMPLE_BITS / 8;
    // Round up when dividing
    opts.packets_per_heap = (opts.heap_size_bytes + opts.packet_payload_size_bytes - 1) / opts.packet_payload_size_bytes;
    opts.timestamp_step =
        opts.n_chans_total * 2 * opts.n_spectra_per_heap; // The *2 is due to the spectrum being cut in half due
                                                          // to symmetric properties of the fourier transform
    return opts;
}

/* Parses the endpoint argument passed into the program as a command line argument.
 *
 * It seperates the endpoint into its multicast ip address and port number and uses this to create an endpoint object.
 *
 * It expects the endpoint argument to follow the x.x.x.x[+y]:port convention where x.x.x.x is the base address, [+y]
 * represents the number of additional multicast streams to launch with consecutive addresses after x.x.x.x.
 */
static std::vector<boost::asio::ip::udp::endpoint> parse_endpoint_list(const std::string &arg)
{
    std::vector<boost::asio::ip::udp::endpoint> out;

    auto colon = arg.find(':');
    if (colon == std::string::npos)
        throw std::invalid_argument("Address must contain a colon");
    std::uint16_t port = boost::lexical_cast<std::uint16_t>(arg.substr(colon + 1));
    auto plus = arg.find('+');
    if (plus < colon)
    {
        std::string start_str = arg.substr(0, plus);
        auto start = boost::asio::ip::address_v4::from_string(start_str);
        int count = boost::lexical_cast<int>(arg.substr(plus + 1, colon - plus - 1));
        for (int i = 0; i <= count; i++)
        {
            boost::asio::ip::address_v4 addr(start.to_ulong() + i);
            out.emplace_back(addr, port);
        }
    }
    else
    {
        auto addr = boost::asio::ip::address_v4::from_string(arg.substr(0, colon));
        out.emplace_back(addr, port);
    }
    return out;
}

/* Class containing an F-Engine output heap as well as the buffer storing data pointed to by the heap. This class
 * generates simulated data to populate the heap buffer.
 */
struct heap_data
{
    std::unique_ptr<std::uint8_t[]> data_ptr;
    spead2::send::heap heap;

    // The timestamp handle is used to modify the heap timestamp after creation. This is needed as this heap will be
    // sent multiple times to reduce processing load and the timestamp needs to be updated each time it is sent.
    spead2::send::heap::item_handle timestamp_handle;

    heap_data(const options &opts, std::int64_t heap_index, int feng_id)
        : data_ptr(std::make_unique<std::uint8_t[]>(opts.heap_size_bytes)), heap(FLAVOUR),
          timestamp_handle(heap.add_item(0x1600, opts.timestamp_step * heap_index))
    {
        /* Heap format defined in section 3.4.5.2.2.1 in the "MeerKAT Functional Interface Control Document for
         * Correlator Beamformer Visibilities and Tied Array Data" (Document ID: M1000-0001-020 rev 4)
         *
         * A rough explanation has been put together showing the exact packet format and byte offsets produced by the
         * F-Engine - available at doc/fgpu.packet_format.rst.
         */

        heap.add_item(0x4101, feng_id);                            // The index of the F-Engine data is sent from
        heap.add_item(0x4103, opts.n_chans_per_output_stream * 2); // frequency base - arbitrary offset at the moment

        /* This field stores sample data. I need to figure out if I can set the shape of the field to have dimensions:
         * [n_chans_total / n_xengs][n_spectra_per_heap][N_POLS][COMPLEXITY] instead of a single long dimension.
         *
         * This function adds an ItemPointer to the header and will append the data in data.get() to the packet
         * payload.
         */
        heap.add_item(0x4300, data_ptr.get(), opts.heap_size_bytes, false); // feng_raw field

        /* The SPEAD header out of the F-Engines is aligned to 256-bit boundaries. To emulate this with spead2, padding
         * needs to be added until the 256-bit boundary is reached.
         */
        for (int pad = 0; pad < 3; pad++)
            heap.add_item(0, 0);

        /* This must be set to true. It will force all immediate values to be sent in every packet instead of once per
         * heap (This applies to the 0x4101, 0x4103 and 0x1600 fields). This is needed to emulate the SKARAB F-Engines
         * as the SKARAB F-Engine duplicates these values in each packet.
         */
        heap.set_repeat_pointers(true);

        /* This section generates the sample data. A patterns is chosen that will hopefully be easy to verify at the
         * receiver graphically. On each F-Engine, the signal amplitude will increase linearly over time for each
         * channel. Each channel will have a different starting amplitude but the rate of increase will be the same for
         * all channels.
         *
         * Each F-Engine will have the same same signal amplitude for the same timestamp, but the signal phase will be
         * different. The signal phase remains constant across all channels in a single F-Engine. By examining the
         * signal phase it can be verified that correct feng_id is attached to the correct data.
         *
         * These samples need to be stored as 8 bit samples. As such, the amplitude is wrapped each time it reaches 127.
         * 127 is used as the amplitude when multiplied by the phase can reach -127. The full range of values is
         * covered.
         *
         * This current format is not fixed and it is likely that it will be adjusted to be suited for different
         * verification needs.
         */
        int initial_offset = heap_index * opts.n_spectra_per_heap;
        double sample_angle_pol0 = 2.0 * M_PI / ((double)(opts.n_ants * N_POLS)) * (feng_id * N_POLS + 0);
        double sample_angle_pol1 = 2.0 * M_PI / ((double)(opts.n_ants * N_POLS)) * (feng_id * N_POLS + 1);
        for (int c = 0; c < opts.n_chans_per_output_stream; c++)
        {
            for (int t = 0; t < opts.n_spectra_per_heap; t++)
            {
                double sample_amplitude = (initial_offset + c * 10 + t) % 127;
                double sample_value_pol0_re = sample_amplitude * std::cos(sample_angle_pol0);
                double sample_value_pol0_im = sample_amplitude * std::sin(sample_angle_pol0);
                double sample_value_pol1_re = sample_amplitude * std::cos(sample_angle_pol1);
                double sample_value_pol1_im = sample_amplitude * std::sin(sample_angle_pol1);

                int sample_index_base =
                    c * opts.n_spectra_per_heap * N_POLS * COMPLEXITY + t * N_POLS * COMPLEXITY;
                data_ptr[sample_index_base + 0] = static_cast<int8_t>(sample_value_pol0_re);
                data_ptr[sample_index_base + 1] = static_cast<int8_t>(sample_value_pol0_im);
                data_ptr[sample_index_base + 2] = static_cast<int8_t>(sample_value_pol1_re);
                data_ptr[sample_index_base + 3] = static_cast<int8_t>(sample_value_pol1_im);
            }
        }
    }
};

/* Class to generate simulated data for a number of different F-Engines and transmit them all on a single multicast
 * address.
 *
 * spead2 has the concept of substreams. Different heaps can be queued on different substreams and then the packets on
 * each heap will be interleaved. This emulates sending data from multiple sources to a single receiver with the caveat
 * that the interleaving is much more predictable than what can be expected from multiple F-Engines. One substream is
 * assigned per F-Engine.
 *
 * This class generates heaps for n_ants F-Engines. A heap is generated once and the transmitted multiple times so that
 * no processing time is spent creating new data.
 *
 * A number of heaps per F-Engine can be queued for flight at any one time - this allows higher transmit rates to be
 * reached. To accomodate this, each F-Engine will have max_heaps pre-generated by this class.
 */
struct fengines
{
    // This variable needs to go first so it is initialised first - it is used during the initialisation of other
    // variables.
    std::uint64_t heaps_per_feng;

    // This vector of vectors stores all the heaps. The outer vector will have one entry for each F-Engine and the inner
    // one will store the heaps per F-Engine.
    std::vector<std::vector<heap_data>> vvHeaps;

    // General variables for coordinating sending of heaps.
    const std::uint64_t uNumAnts;
    std::uint64_t timestamp = 0;
    std::uint64_t next_heap = 0;

    // Step between timestamps of succesive heaps belonging to the same antenna.
    const std::int64_t timestamp_step;

    // Only transmit a single collection of heaps and then end the transmission.
    const bool run_once;

    // SPEAD 2 stream that every heap will be queued on.
    spead2::send::udp_ibv_stream stream;

    /* Constructor for the fengines simulator.
     *
     * Initialises the spead2 stream. The stream requires two main objects, the
     * stream_config() for general stream parameters and the udp_ibv_config() for more specific parameters required when
     * using ibverbs to accelerate the packet transmission.
     *
     * Creates all heaps that will queued on the spead2 stream.
     */
    fengines(const options &opts, const std::vector<boost::asio::ip::udp::endpoint> &endpoints,
             const boost::asio::ip::address &interface_address, boost::asio::io_service &ios)
        : heaps_per_feng(opts.max_heaps), vvHeaps(make_heaps(opts)), uNumAnts(opts.n_ants),
          timestamp_step(opts.timestamp_step), run_once(opts.run_once),
          stream(ios,
                 spead2::send::stream_config()
                     .set_max_packet_size(opts.packet_payload_size_bytes + PACKET_HEADER_SIZE_BYTES)
                     .set_rate(opts.adc_sample_rate
                 * N_POLS * SAMPLE_BITS / 8.0 *
                               opts.n_ants * opts.n_chans_per_output_stream / opts.n_chans_total *
                               (opts.heap_size_bytes + opts.packets_per_heap * PACKET_HEADER_SIZE_BYTES) /
                               opts.heap_size_bytes)
                     .set_max_heaps(opts.max_heaps * opts.n_ants),
                 spead2::send::udp_ibv_config()
                     .set_endpoints(endpoints)
                     .set_interface_address(interface_address)
                     .set_ttl(opts.ttl)
                     .set_memory_regions(get_memory_regions(opts, vvHeaps)))
    {
    }

    /* Registers all heap data in memory regions and returns a vector of these regions to be used by spead2.
     *
     * Memory regions are an ibverbs concept. Any collection of data that ibverbs needs to send on the network needs to
     * be in a memory region. The channel data in each heap is what is being sent in this case, and each one of these
     * needs to be added to a memory region.
     */
    static std::vector<std::pair<const void *, std::size_t>> get_memory_regions(
        const options &opts, const std::vector<std::vector<heap_data>> &vvAllHeaps)
    {
        std::vector<std::pair<const void *, std::size_t>> vMemoryRegions;
        for (const std::vector<heap_data> &vSingleFengineHeaps : vvAllHeaps)
        {
            for (const heap_data &heap : vSingleFengineHeaps)
            {
                vMemoryRegions.emplace_back(heap.data_ptr.get(), opts.heap_size_bytes);
            }
        }
        return vMemoryRegions;
    }

    /* Creates vector of heaps required to be transmitted by the F-Engine simulator.
     *
     * This static method is a bit messy, there is probably a simpler way to do it.
     */
    static std::vector<std::vector<heap_data>> make_heaps(const options &opts)
    {
        std::vector<std::vector<heap_data>> vv2AllFengineHeaps;
        vv2AllFengineHeaps.reserve(opts.n_ants);
        int heaps_per_feng = opts.max_heaps;
        for (int feng_id = 0; feng_id < opts.n_ants; feng_id++)
        {
            std::vector<heap_data> vFengineHeaps;
            vFengineHeaps.reserve(heaps_per_feng);
            for (int heap_index = 0; heap_index < heaps_per_feng; heap_index++)
            {
                vFengineHeaps.emplace_back(opts, heap_index, feng_id);
            }
            vv2AllFengineHeaps.emplace_back(std::move(vFengineHeaps));
        }
        return vv2AllFengineHeaps;
    }

    /* Adds the next collection of heaps to the spead2 stream queue.
     *
     * Heaps from multiple different indexes with
     *
     * This function keeps track of the index of the next collection of heaps to send.
     *
     * It is non-blocking, once heaps have been added to the stream, this function will return - there is no guarentee
     * that the heap will have been sent.
     */
    void send_next()
    {
        /* In order to send a collection of heaps with packets interleaved, they need to be given to spead2 to in one
         * collection using the stream.async_send_heaps function. This function requires iterators of type
         * spead2::send::heap_reference. A heap_reference points to an underlying heap. Here we construct the vector of
         * heap references as required.
         */
        std::vector<spead2::send::heap_reference> vHeapsToInterleave;
        vHeapsToInterleave.reserve(uNumAnts);
        for (size_t feng_index = 0; feng_index < uNumAnts; feng_index++)
        {
            vvHeaps[feng_index][next_heap]
                .heap.get_item(vvHeaps[feng_index][next_heap].timestamp_handle)
                .data.immediate = timestamp;
            /* The f_engine_index argument tells spead2 which substream to queue the heap on. It is important that each
             * F-Engine gets its own unique substream index as heaps with different indexes will be interleaved which is
             * desired.
             */
            vHeapsToInterleave.emplace_back(vvHeaps[feng_index][next_heap].heap, -1, feng_index);
        }

        bool queue_success =
            stream.async_send_heaps(vHeapsToInterleave.begin(), vHeapsToInterleave.end(),
                                    std::bind(&fengines::callback, this, std::placeholders::_1, std::placeholders::_2),
                                    spead2::send::group_mode::ROUND_ROBIN);
        if (queue_success == false)
        {
            std::cerr << "Error: Heaps not queued succesfully on queue" << std::endl;
            std::exit(1);
        }

        timestamp += timestamp_step;
        next_heap++;

        if (next_heap == heaps_per_feng)
            next_heap = 0;
    }

    /* Callback function called when spead2 finishes sending a collection of heaps sent by @ref send_next().
     *
     * This function immediatley queues the next collection of heaps to be sent on the network.
     */
    void callback(const boost::system::error_code &ec, std::size_t)
    {
        if (ec)
        {
            std::cerr << "Error: " << ec;
            std::exit(1);
        }
        else if (!run_once)
        {
            send_next();
        }
    }
};

/* Create fengines objects and start IO loop to kick off packet tranmission.
 */
int main(int argc, const char **argv)
{
    // 1. IO loop that will be used by all multicast streams.
    boost::asio::io_service io_serv;

    // 2. Parse all the command line parameters
    options opts = parse_options(argc, argv);
    auto interface_addr = boost::asio::ip::address::from_string(opts.interface_name);
    std::vector<boost::asio::ip::udp::endpoint> endpoints = parse_endpoint_list(opts.strAddress);

    // 3. Create multicast stream objects
    std::deque<fengines> vMulticastStreams; // We use a deque as unlike a vector it does not require the fengines object
                                            // to have a copy constructor.

    // 3. Create a multicast stream for each endpoint specified in the command line.
    for (size_t j = 0; j < endpoints.size(); j++)
    {
        // 3.1 Create an endpoint list to pass to the fengines object contructor.
        // Instead of passing a single endpoint into the stream, we create a list continaing n_ants duplicates of the
        // same endpoint. This is because the spead2 stream object within the fengines object uses one substream for
        // each antenna and each substream needs its own entry in an endpoint list. Duplication is the simplest way to
        // achieve this. This duplication is really an internal working of the fengines class and should be moved to
        // within that class. I have not yet figured out the best way to do this.
        std::vector<boost::asio::ip::udp::endpoint> vEndpointsForSingleStream;
        for (int i = 0; i < opts.n_ants; i++)
        {
            vEndpointsForSingleStream.emplace_back(endpoints[j]);
        }

        // 3.2 Construct the fengines object for a specific multicast stream
        vMulticastStreams.emplace_back(opts, vEndpointsForSingleStream, interface_addr, io_serv);
        std::cout << "Created multicast stream: " << endpoints[j].address().to_string() << ":" << endpoints[j].port()
                  << std::endl;
    }

    // 4. Kick off packet transmission
    float data_rate_gbps = opts.adc_sample_rate * N_POLS * SAMPLE_BITS *
                           opts.n_ants * opts.n_chans_per_output_stream / opts.n_chans_total *
                           (opts.heap_size_bytes + opts.packets_per_heap * PACKET_HEADER_SIZE_BYTES) /
                           opts.heap_size_bytes / 1e9;
    std::cout << "Beginning fsim data transmission at " << data_rate_gbps << " Gbps..." << std::endl;

    for (size_t i = 0; i < endpoints.size(); i++)
    {
        // 4.1 The first send_next() function of each multicast stream needs to be queued manually. Once these sends
        // have completed, the callback function called will ensure that send_next() function is called again (assuming
        // run_once == false)
        io_serv.post(std::bind(&fengines::send_next, &vMulticastStreams[i]));
    }

    // 4.2 Start IO loop running.
    io_serv.run();
    return 0;
}
