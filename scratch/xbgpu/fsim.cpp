/* This program creates a simulator for channelised data from the MeerKAT F-Engines destined for a single X-Engine.
 * When there are N antennas, the X-Engine recieves channels from N F-Engines. This simulator simulates this behaviour
 * by interleaving packets with differently-populated fields designed to mimic the different antennas. One caveat to
 * this simulator is that the data is perfectly interleaved and ordered. It does not simulate the messier environment
 * that occurs when running multiple real F-Engines all transmitting along different paths.
 *
 * This simulator was modified from the dsim.cpp document found within katfgpu:
 * https://github.com/ska-sa/katfgpu/blob/master/scratch/dsim.cpp
 *
 * This simulator uses the SPEAD2 library to transmit the F-Engine data. SPEAD2 uses ibverbs to accelerate packet
 * transmission. Lossless transmit rates up to 34 Gbps have been tested, but it is expected that higher rates can be
 * achieved. By default root access is required to use ibverbs.
 *
 * The minimum command to run the fsim is: sudo ./fsim --interface <interface_address> <multicast_address>:<port>
 * Where:
 * <interface_address> is the ip address of the network interface to transmit the data out on.
 * <multicast_address> is the multicast address all packets are destined for
 * <port> is the UDP port to transmit data to.
 *
 * By default the fsim transmits data at 6.8 Gbps + packet overhead. This depends on the sample rate of the antenna ADCs
 * and the number of pols. The data rate is equal to adc_rate * number_of_pols * sample_size_bits / 4 = 1712000000 * 2 *
 * 8 / 4 = 6.8 Gbps. The /4 accounts for there being 4 multicast streams for every 1 F-Engine .To change the rate pass
 * a different value into the program with the --adc_rate <adc sample rate in hz> argument.
 *
 * This file has an "fengines" class that manages the SPEAD streams and packet transmission. The fengines object 
 * contains a 2 dimensional vector of heaps. The outer dimension represents the different F-Engines and the inner
 * dimension contains the heaps to send per F-Engine. The array of heaps is generated once and then transmitted 
 * repeatedly on the network.
 *
 * n_chans_per_output_stream and n_chans_total can be specified individually as command line parameters. For
 * MeerKAT, this is not necessary as n_chans_per_output_stream can be calculated from n_chans_total, for the MeerKAT
 * Extension, this relationship may not hold true for non-power-of-two array sizes so the values have been kept
 * seperate. n_chans_total is only used to calculate the timestamp step to expect between heaps, it does not impact
 * anything else.
 *
 * The format of the data generated by the fsim is discussed in the heap_data class below.
 */

#include <spead2/send_udp_ibv.h>

#include <boost/program_options.hpp>
#include <cmath>
#include <cstdint>
#include <cstdlib>
#include <iomanip>
#include <iostream>
#include <memory>
#include <random>
#include <vector>

struct options
{
    std::string strInterface;
    std::string strAddress;
    int iMaxHeaps = 8;
    double dAdcRate = 1712000000.0;
    int iTtl = 4;
    int n_ants = 64;
    int n_chans_per_output_stream = 128;
    int n_chans_total = 32768;
    int n_time_samples_per_channel = 256;

    // The variables below are not command-line arguments, they are just calculated based on values provided by the
    // command line. This method of passing these arguments is a bit clunky, but I have not put effort into fixing it.
    size_t heap_size_bytes;
    size_t packet_payload_size_bytes;
    size_t packets_per_heap;
    size_t timestamp_step; // This is the amount the timestamp must increment between successive heaps of the same
                        // F-Engine.
};

// TODO: These constexpr could be neatened up a bit.

static constexpr int sample_bits = 8; // This is not very meaningful for the X-Engine but this argument is left here to
                                      // be consistent with the F-Engine packet simulator.
static constexpr size_t n_multicast_streams_per_antenna = 4;
static constexpr size_t n_pols = 2;                    // Dual polarisation antennas
static constexpr size_t complexity = 2;                // real and imaginary components
static constexpr size_t packet_header_size_bytes = 96; // Nine 8-byte header fields and three padding fields.

// The 64 indicates that each header SPEAD2 item is 64-bits wide. The 48 value means that the ItemPointers will have 48
// bits representing the immediate value or pointer to payload. The other 16 bits will be used for the item ID.
static const spead2::flavour oFlavour(4, 64, 48);

// Function to assist with parsing command line parameters
template <typename T> static boost::program_options::typed_value<T> *make_opt(T &var)
{
    return boost::program_options::value<T>(&var)->default_value(var);
}

// Parse command line parameters - this has been kludged  together. It can probably be done in a neater way.
static options parse_options(int argc, const char **argv)
{
    options opts;
    boost::program_options::options_description desc, hidden, all("F- to X- Engine simulator");
    desc.add_options()("help", "produce help message");
    desc.add_options()("interface", boost::program_options::value(&opts.strInterface)->required(),
                       "Interface address to send data out on.");
    desc.add_options()("max-heaps", make_opt(opts.iMaxHeaps), "Maximum number of heaps per F-Engine.");
    desc.add_options()("adc-rate", make_opt(opts.dAdcRate), "Sampling rate of digitisers feeding the F-Engine");
    desc.add_options()("ttl", make_opt(opts.iTtl), "Output TTL (Time to live)");
    desc.add_options()("array-size", make_opt(opts.n_ants), "Number of antennas in the array");
    desc.add_options()("fft-channels", make_opt(opts.n_chans_total),
                       "Number of channels out of the FFT. (Normally half of FFT size)");
    desc.add_options()("channels-per-substream", make_opt(opts.n_chans_per_output_stream),
                       "Each F-Engine output substream transmits a subset of the FFT channels.");
    desc.add_options()("samples-per-channel", make_opt(opts.n_time_samples_per_channel),
                       "The F-Engine cornerturn groups a number of samples into each channel per packet.");
    hidden.add_options()("address", boost::program_options::value<std::string>(&opts.strAddress)->composing(),
                         "destination address, in form x.x.x.x:port");
    all.add(desc);
    all.add(hidden);
    boost::program_options::positional_options_description positional;
    positional.add("address", -1);
    try
    {
        boost::program_options::variables_map vm;
        boost::program_options::store(
            boost::program_options::command_line_parser(argc, argv).options(all).positional(positional).run(), vm);
        boost::program_options::notify(vm);
        if (opts.iMaxHeaps <= 0)
            throw boost::program_options::error("--max-heaps must be positive");

        if (vm.count("help"))
        {
            std::cout << all << "\n";
            std::exit(1);
        }
    }
    catch (boost::program_options::error &e)
    {
        std::cerr << e.what() << '\n';
        std::exit(2);
    }

    /*
     * NOTE: For the F-Engine output case, each heap is quite large but contains many smaller packets. Each packet
     * encapsualtes a single channel's worth of samples. Each packet also contains other SPEAD data and is thus slightly
     * larger than 1 KiB.
     */
    opts.heap_size_bytes =
        opts.n_chans_per_output_stream * opts.n_time_samples_per_channel * n_pols * complexity * sample_bits / 8;
    opts.packet_payload_size_bytes = opts.n_time_samples_per_channel * n_pols * complexity;
    opts.packets_per_heap = opts.heap_size_bytes / opts.packet_payload_size_bytes;
    opts.timestamp_step =
        opts.n_chans_total * 2 * opts.n_time_samples_per_channel; // The *2 is due to the spectrum being cut in half due
                                                                  // to symmetric properties of the fourier transform
    return opts;
}

/* This function parses the endpoint argument passed in the program as a command line argument.
 *
 * It seperates the endpoint into its multicast ip address and port number and uses this to create an endpoint object.
 *
 * Instead of returning a single endpoint, it returns n_ants duplicates of the same endpoint. This is because the SPEAD2
 * stream object uses one substream for each antenna and each substream needs its own entry in endpoint list.
 * Duplication is the simplest way to achieve this.
 *
 * The location of this function is not too important. It could be a static method in the fengines class but has not
 * been moved as this is not a priority.
 */
static std::vector<boost::asio::ip::udp::endpoint> parse_endpoint(const options &opts)
{
    std::vector<boost::asio::ip::udp::endpoint> out;

    auto colon = opts.strAddress.find(':');
    if (colon == std::string::npos)
        throw std::invalid_argument("Address must contain a colon");

    std::uint16_t u16Port = boost::lexical_cast<std::uint16_t>(opts.strAddress.substr(colon + 1));
    for (int i = 0; i < opts.n_ants; i++)
    {
        auto addr = boost::asio::ip::address_v4::from_string(opts.strAddress.substr(0, colon));
        out.emplace_back(addr, u16Port);
    }
    return out;
}

/* Class containing an F-Engine output heap as well as the buffer storing data pointed to by the heap. This class
 * generates simulated data to populate the heap buffer.
 */
struct heap_data
{
    std::unique_ptr<std::uint8_t[]> pu8Data;
    spead2::send::heap heap;

    // The timestamp handle is used to modify the heap timestamp after creation. This is needed as this heap will be
    // sent multiple times to reduce processing load and the timestamp needs to be updated each time it is sent.
    spead2::send::heap::item_handle timestampHandle;

    heap_data(const options &opts, std::int64_t i64HeapIndex, int iFengId)
        : pu8Data(std::make_unique<std::uint8_t[]>(opts.heap_size_bytes)), heap(oFlavour),
          timestampHandle(heap.add_item(0x1600, opts.timestamp_step * i64HeapIndex))
    {
        /* Heap format defined in section 3.4.5.2.2.1 in the "MeerKAT Functional Interface Control Document for
         * Correlator Beamformer Visibilities and Tied Array Data" (Document ID: M1000-0001-020 rev 4)
         *
         * A rough document has been put together showing the exact packet format and byte offsets produced by the
         * F-Engine: https://docs.google.com/drawings/d/1lFDS_1yBFeerARnw3YAA0LNin_24F7AWQZTJje5-XPg/edit
         */

        heap.add_item(0x4101, iFengId);                            // The index of the F-Engine data is sent from
        heap.add_item(0x4103, opts.n_chans_per_output_stream * 2); // frequency base - arbitrary offset at the moment

        /* This field stores sample data. I need to figure out if I can set the shape of the field to have dimensions:
         * [n_chans_total / n_xengs][n_time_samples_per_channel][n_pols][complexity] instead of a single long dimension.
         *
         * This function adds an ItemPointer to the header and will append the data in data.get() to the packet
         * payload.
         */
        heap.add_item(0x4300, pu8Data.get(), opts.heap_size_bytes, false); // feng_raw field

        /* The SPEAD header out of the F-Engines is aligned to 256-bit boundaries. To emulate this with SPEAD2, padding
         * needs to be added until the 256-bit boundary is reached.
         */
        for (int pad = 0; pad < 3; pad++)
            heap.add_item(0, 0);

        /* This must be set to true. It will force all immediate values to be sent in every packet instead of once per
         * heap (This applies to the 0x4101, 0x4103 and 0x1600 fields). This is needed to emulate the SKARAB F-Engines
         * as the SKARAB F-Engine duplicates these values in each packet.
         */
        heap.set_repeat_pointers(true);

        /* This section generates the sample data. A patterns is chosen that will hopefully be easy to verify at the
         * receiver graphically. On each F-Engine, the signal amplitude will increase linearly over time for each
         * channel. Each channel will have a different starting amplitude but the rate of increase will be the same for
         * all channels.
         *
         * Each F-Engine will have the same same signal amplitude for the same timestamp, but the signal phase will be
         * different. The signal phase remains constant across all channels in a single F-Engine. By examining the
         * signal phase it can be verified that correct feng_id is attached to the correct data.
         *
         * These samples need to be stored as 8 bit samples. As such, the amplitude is wrapped each time it reaches 127.
         * 127 is used as the amplitude when multiplied by the phase can reach -127. The full range of values is
         * covered.
         *
         * This current format is not fixed and it is likely that it will be adjusted to be suited for different
         * verification needs.
         */
        int iInitialOffset = i64HeapIndex * opts.n_time_samples_per_channel;
        double dSampleAnglePol0 = 2.0 * M_PI / ((double)(opts.n_ants * n_pols)) * (iFengId * n_pols + 0);
        double dSampleAnglePol1 = 2.0 * M_PI / ((double)(opts.n_ants * n_pols)) * (iFengId * n_pols + 1);
        for (int c = 0; c < opts.n_chans_per_output_stream; c++)
        {
            for (int t = 0; t < opts.n_time_samples_per_channel; t++)
            {
                double dSampleAmplitude = (iInitialOffset + c * 10 + t) % 127;
                double dSampleValuePol0Real = dSampleAmplitude * std::cos(dSampleAnglePol0);
                double dSampleValuePol0Imag = dSampleAmplitude * std::sin(dSampleAnglePol0);
                double dSampleValuePol1Real = dSampleAmplitude * std::cos(dSampleAnglePol1);
                double dSampleValuePol1Imag = dSampleAmplitude * std::sin(dSampleAnglePol1);

                int iSampleIndexBase =
                    c * opts.n_time_samples_per_channel * n_pols * complexity + t * n_pols * complexity;
                pu8Data[iSampleIndexBase + 0] = static_cast<int8_t>(dSampleValuePol0Real);
                pu8Data[iSampleIndexBase + 1] = static_cast<int8_t>(dSampleValuePol0Imag);
                pu8Data[iSampleIndexBase + 2] = static_cast<int8_t>(dSampleValuePol1Real);
                pu8Data[iSampleIndexBase + 3] = static_cast<int8_t>(dSampleValuePol1Imag);
            }
        }
    }
};

/* Class to generate simulated data for a number of different F-Engines and transmit them all on a single multicast
 * address.
 *
 * SPEAD2 has the concept of substreams. Different heaps can be queued on different substreams and then the packets on
 * each heap will be interleaved. This emulates sending data from multiple sources to a single receiver with the caveat
 * that the interleaving is much more predictable than what can be expected from multiple F-Engines. One substream is
 * assigned per F-Engine. (TODO: Force interleaving by using async_send_heaps instead of async_send_heap).
 *
 * This class generates heaps for n_ants F-Engines. A heap is generated once and the transmitted multiple times so that
 * no processing time is spent creating new data.
 *
 * A number of heaps per F-Engine can be queued for flight at any one time - this allows higher transmit rates to be
 * reached. To accomodate this, each F-Engine will have max_heaps pre-generated by this class.
 */
struct fengines
{
    // This variable needs to go first so it is initialised first - it is used during the initialisation of other
    // variables.
    std::uint64_t u64HeapsPerFEngine;

    // SPEAD2 has its own set of threads that manage transmitting data. When SPEAD2 finishes sending a heap, it queues a
    // handler on this IO loop that is then called.
    boost::asio::io_service ioService;

    // This vector of vectors stores all the heaps. The outer vector will have one entry for each F-Engine and the inner
    // one will store the heaps per F-Engine.
    std::vector<std::vector<heap_data>> vvHeaps;

    // General variables for coordinating sending of heaps.
    const std::uint64_t uNumAnts;
    std::uint64_t u64Timestamp = 0;
    std::uint64_t uNextHeap = 0;

    // Step between timestamps of succesive heaps belonging to the same antenna.
    const std::int64_t u64TimestampStep;

    // SPEAD 2 stream that every heap will be queued on.
    spead2::send::udp_ibv_stream stream;

    /* Constructor for the fengines simulator.
     *
     * Initialises the SPEAD2 stream. The stream requires two main objects, the
     * stream_config() for general stream parameters and the udp_ibv_config() for more specific parameters required when
     * using ibverbs to accelerate the packet transmission.
     *
     * Creates all heaps that will queued on the SPEAD2 stream.
     */
    fengines(const options &opts, const std::vector<boost::asio::ip::udp::endpoint> &endpoints,
             const boost::asio::ip::address &interface_address)
        : u64HeapsPerFEngine(opts.iMaxHeaps), vvHeaps(make_heaps(opts)), uNumAnts(opts.n_ants),
          u64TimestampStep(opts.timestamp_step),
          stream(ioService,
                 spead2::send::stream_config()
                     .set_max_packet_size(opts.packet_payload_size_bytes + packet_header_size_bytes)
                     .set_rate(opts.dAdcRate * n_pols * sample_bits / 8.0 *
                               (opts.heap_size_bytes + opts.packets_per_heap * packet_header_size_bytes) /
                               opts.heap_size_bytes / n_multicast_streams_per_antenna)
                     .set_max_heaps(opts.iMaxHeaps * opts.n_ants),
                 spead2::send::udp_ibv_config()
                     .set_endpoints(endpoints)
                     .set_interface_address(interface_address)
                     .set_ttl(opts.iTtl)
                     .set_memory_regions(get_memory_regions(opts, vvHeaps)))
    {
    }

    /* Registers all heap data in memory regions and returns a vector of these regions to be used by SPEAD2.
     *
     * Memory regions are an ibverbs concept. Any collection of data that ibverbs needs to send on the network needs to
     * be in a memory region. The channel data in each heap is what is being sent in this case, and each one of these
     * needs to be added to a memory region.
     */
    static std::vector<std::pair<const void *, std::size_t>> get_memory_regions(
        const options &opts, const std::vector<std::vector<heap_data>> &vvAllHeaps)
    {
        std::vector<std::pair<const void *, std::size_t>> vMemoryRegions;
        for (const std::vector<heap_data> &vSingleFengineHeaps : vvAllHeaps)
        {
            for (const heap_data &heap : vSingleFengineHeaps)
            {
                vMemoryRegions.emplace_back(heap.pu8Data.get(), opts.heap_size_bytes);
            }
        }
        return vMemoryRegions;
    }

    /* Creates vector of heaps required to be transmitted by the F-Engine simulator.
     *
     * This static method is a bit messy, there is probably a simpler way to do it.
     */
    static std::vector<std::vector<heap_data>> make_heaps(const options &opts)
    {
        std::vector<std::vector<heap_data>> vv2AllFengineHeaps;
        vv2AllFengineHeaps.reserve(opts.n_ants);
        int iHeapsPerFengine = opts.iMaxHeaps;
        for (int feng_id = 0; feng_id < opts.n_ants; feng_id++)
        {
            std::vector<heap_data> vFengineHeaps;
            vFengineHeaps.reserve(iHeapsPerFengine);
            for (int heap_index = 0; heap_index < iHeapsPerFengine; heap_index++)
            {
                vFengineHeaps.emplace_back(opts, heap_index, feng_id);
            }
            vv2AllFengineHeaps.emplace_back(std::move(vFengineHeaps));
        }
        return vv2AllFengineHeaps;
    }

    /* Adds the next collection of heaps to the SPEAD2 stream queue.
     *
     * Heaps from multiple different indexes with
     *
     * This function keeps track of the index of the next collection of heaps to send.
     *
     * It is non-blocking, once heaps have been added to the stream, this function will return - there is no guarentee
     * that the heap will have been sent.
     */
    void send_next()
    {
        /* In order to send a collection of heaps with packets interleaved, they need to be given to SPEAD2 to in one
         * collection using the stream.async_send_heaps function. This function requires iterators of type
         * spead2::send::heap_reference. A heap_reference points to an underlying heap. Here we construct the vector of
         * heap references as required.
         */
        std::vector<spead2::send::heap_reference> vHeapsToInterleave;
        vHeapsToInterleave.reserve(uNumAnts);
        for (size_t ulFEngineIndex = 0; ulFEngineIndex < uNumAnts; ulFEngineIndex++)
        {
            vvHeaps[ulFEngineIndex][uNextHeap]
                .heap.get_item(vvHeaps[ulFEngineIndex][uNextHeap].timestampHandle)
                .data.immediate = u64Timestamp;
            /* The f_engine_index argument tells SPEAD2 which substream to queue the heap on. It is important that each
             * F-Engine gets its own unique substream index as heaps with different indexes will be interleaved which is
             * desired.
             */
            vHeapsToInterleave.emplace_back(vvHeaps[ulFEngineIndex][uNextHeap].heap, -1, ulFEngineIndex);
        }

        bool bQueueSuccesful =
            stream.async_send_heaps(vHeapsToInterleave.begin(), vHeapsToInterleave.end(),
                                    std::bind(&fengines::callback, this, std::placeholders::_1, std::placeholders::_2),
                                    spead2::send::group_mode::ROUND_ROBIN);
        if (bQueueSuccesful == false)
        {
            std::cerr << "Error: Heaps not queued succesfully on queue" << std::endl;
            std::exit(1);
        }

        u64Timestamp += u64TimestampStep;
        uNextHeap++;

        if (uNextHeap == u64HeapsPerFEngine)
            uNextHeap = 0;
    }

    /* Callback function called when SPEAD2 finishes sending a collection of heaps sent by @ref send_next().
     *
     * This function immediatley queues the next collection of heaps to be sent on the network.
     */
    void callback(const boost::system::error_code &ec, std::size_t)
    {
        if (ec)
        {
            std::cerr << "Error: " << ec;
            std::exit(1);
        }
        else
        {
            send_next();
        }
    }
};

/* Create fengines object and start IO loop to kick off packet tranmission.
 */
int main(int argc, const char **argv)
{
    options opts = parse_options(argc, argv);

    auto interfaceAddress = boost::asio::ip::address::from_string(opts.strInterface);
    std::vector<boost::asio::ip::udp::endpoint> endpoints = parse_endpoint(opts);

    fengines f(opts, endpoints, interfaceAddress);
    f.ioService.post(std::bind(&fengines::send_next, &f));

    // Will run forever.
    f.ioService.run();
    return 0;
}
